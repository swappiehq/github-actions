name: Update asdf plugin
description: Updates asdf .tool-versions and Dockerfile for given plugin
inputs:
  plugin:
    type: string
    required: true
  docker_image:
    type: string
    required: false
    default: ""
  version:
    type: choice
    default: latest
    required: true
    description: Selects the level of updates available for this action
    options:
      - latest
      - lts
      - minor # Semver minor updates from MAJOR.MINOR.PATCH
      - patch # Semver patch updates from MAJOR.MINOR.PATCH
  release_notes:
    type: string
    required: true
  package_json_prefix:
    type: string
    required: false
    default: "."
  add_extra_files_to_pr:
    type: string
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - uses: actions/checkout@v3
    # Refer to external action with git commit SHA for security.
    # Source: https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions
    - name: ASDF Setup plugins
      uses: asdf-vm/actions/plugins-add@6844d09b13209e7d2ce3b63d2b089a2acef581ec
    - name: Get current version from asdf
      shell: bash
      run: echo "CURRENT_VERSION=$(grep "^${{ inputs.plugin }}" .tool-versions | cut -d' ' -f2)" >> $GITHUB_ENV
    - name: Get latest version from asdf
      if: ${{ inputs.version == 'latest' }}
      shell: bash
      run: |
        LATEST_VERSION=$(asdf latest "${{ inputs.plugin }}")
        echo "LATEST_VERSION=${LATEST_VERSION}" >> $GITHUB_ENV
    - name: Get latest minor version from asdf
      if: ${{ inputs.version == 'minor' }}
      shell: bash
      run: |
        CURRENT_MINOR_VERSION=$(echo ${{ env.CURRENT_VERSION }} | cut -d '.' -f 1)
        LATEST_VERSION=$(asdf latest "${{ inputs.plugin }}" $CURRENT_MINOR_VERSION)
        echo "LATEST_VERSION=${LATEST_VERSION}" >> $GITHUB_ENV
    - name: Get latest patch version from asdf
      if: ${{ inputs.version == 'patch' }}
      shell: bash
      run: |
        CURRENT_PATCH_VERSION=$(echo ${{ env.CURRENT_VERSION }} | cut -d '.' -f 1,2)
        LATEST_VERSION=$(asdf latest "${{ inputs.plugin }}" $CURRENT_PATCH_VERSION)
        echo "LATEST_VERSION=${LATEST_VERSION}" >> $GITHUB_ENV
    # NodeJS has LTS versions
    - name: Get newest NodeJS LTS version
      if: ${{ inputs.version == 'lts' && inputs.plugin == 'nodejs' }}
      shell: bash
      run: |
        LATEST_VERSION=$(asdf latest nodejs $(asdf nodejs resolve lts))
        echo "LATEST_VERSION=${LATEST_VERSION}" >> $GITHUB_ENV
    - name: Create release notes link
      shell: bash
      run: |
        LATEST_VERSION=${{ env.LATEST_VERSION }}
        MAJOR_VERSION=$(echo $LATEST_VERSION | cut -d '.' -f 1)
        MINOR_VERSION=$(echo $LATEST_VERSION | cut -d '.' -f 1,2)
        LATEST_VERSION_WITH_DASHES=$(echo $LATEST_VERSION | tr . -)
        RELEASE_NOTES=$(eval echo "${{ inputs.release_notes }}")
        echo "Updating from ${{ env.CURRENT_VERSION }} to ${{ env.LATEST_VERSION }}"
        echo "RELEASE_NOTES=${RELEASE_NOTES}" >> $GITHUB_ENV
    # This is much faster since asdf local command requires installing the new version
    - name: Update latest version to .tool-versions
      shell: bash
      run: |
        sed -i "s/^${{ inputs.plugin }} ${{ env.CURRENT_VERSION }}/${{ inputs.plugin }} ${{ env.LATEST_VERSION }}/" .tool-versions
    - name: Update latest version to Dockerfile
      shell: bash
      run: |
        test -n "${{ inputs.docker_image }}" && test -f Dockerfile && sed -i "s/^FROM ${{ inputs.docker_image }}:${{ env.CURRENT_VERSION }}/FROM ${{ inputs.docker_image }}:${{ env.LATEST_VERSION }}/" Dockerfile
    # This fetches the bundled NPM version from nodejs.org so that we don't need to install nodejs+npm packages here
    - name: Update latest node/npm versions to package.json engines if it exists
      if: ${{ inputs.plugin == 'nodejs' && env.CURRENT_VERSION != env.LATEST_VERSION }}
      shell: bash
      run: |
        PACKAGE_JSON=${{ inputs.package_json_prefix }}/package.json
        LOCK_JSON=${{ inputs.package_json_prefix }}/package-lock.json
        test -f $PACKAGE_JSON && jq ".engines" $PACKAGE_JSON || { echo "Skipping update since package.json or engines don't exist"; exit 0; }
        asdf install nodejs ${{ env.LATEST_VERSION }}
        BUNDLED_NPM_VERSION=$(asdf exec npm --version)
        [[ "$BUNDLED_NPM_VERSION" =~ ^[.0-9]+$ ]] || { echo "Failed to fetch the new NPM version. Got malformed version: $BUNDLED_NPM_VERSION"; exit 1; }
        jq ".engines.node = \"^${{ env.LATEST_VERSION }}\" | .engines.npm = \"^$BUNDLED_NPM_VERSION\"" $PACKAGE_JSON > updated-package.json
        jq ".packages.\"\".engines.node = \"^${{ env.LATEST_VERSION }}\" | .packages.\"\".engines.npm = \"^$BUNDLED_NPM_VERSION\"" $LOCK_JSON > updated-package-lock.json
        mv updated-package.json $PACKAGE_JSON
        mv updated-package-lock.json $LOCK_JSON
    
    # The earlier 'ASDF Setup plugins' step already installs all used plugins
    # We only need python/poetry here so cherry-pick install them from all possible things
    # from .tool-versions file
    - name: Update latest python version to pyproject.toml if it exists
      if: ${{ inputs.plugin == 'python' && env.CURRENT_VERSION != env.LATEST_VERSION }}
      shell: bash
      run: |
        test -f pyproject.toml && \
        sed -i "s/^python =.*/python = \"^${{ env.LATEST_VERSION }}\"/" pyproject.toml && \
        asdf install python && \
        asdf install poetry && \
        poetry lock --no-update
    - name: Update latest poetry version to pyproject.toml if it exists
      if: ${{ inputs.plugin == 'poetry' && env.CURRENT_VERSION != env.LATEST_VERSION }}
      shell: bash
      run: |
        test -f pyproject.toml && \
        poetry version ${{ env.LATEST_VERSION }} && \
        asdf install poetry && \
        poetry lock --no-update

    # This is using the version 4.2.3
    # Reference the repository with SHA for security
    # Source: https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions
    # Here we use a wild card for the package.json files to avoid "pathspec 'xxx' did not match any files" errors as package.json files may not exist or be in subdirectories
    - uses: peter-evans/create-pull-request@2b011faafdcbc9ceb11414d64d0573f37c774b04
      with:
        add-paths: .tool-versions, Dockerfile${{inputs.add_extra_files_to_pr != '' && format(', {0}', inputs.add_extra_files_to_pr) || '' }}
        commit-message: 'Update ${{ inputs.plugin }} from ${{ env.CURRENT_VERSION }} to ${{ env.LATEST_VERSION }}'
        title: 'Update ${{ inputs.plugin }} from ${{ env.CURRENT_VERSION }} to ${{ env.LATEST_VERSION }}'
        branch: 'update/${{ inputs.plugin }}/${{ env.LATEST_VERSION }}'
        body: 'See release notes in: ${{ env.RELEASE_NOTES }}'
        delete-branch: true
        labels: 'dependencies,${{ inputs.github_pullrequest_labels }}'
        author: 'GitHub <noreply@github.com>'
